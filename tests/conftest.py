# ---------------------------------------------
# conftest.py â€“ Pytest fixtures for integration testing
# ---------------------------------------------

# Import required libraries
import pytest  # Pytest is used for defining fixtures and writing test cases
from fastapi.testclient import TestClient  # Used to simulate HTTP requests to FastAPI routes
from sqlalchemy import create_engine  # Creates the test DB engine
from sqlalchemy.orm import sessionmaker, Session  # ORM tools to create DB sessions

# Import FastAPI app and DB dependency
from app.main import app  # Your FastAPI app instance
from app.database import get_db  # The real get_db dependency used in your routes
from app import models  # To ensure all models like Claim are imported

# -------------------------------
# DATABASE CONFIGURATION FOR TESTING
# -------------------------------

# Create a test SQLite database stored in a file named test.db (safe for integration tests)
TEST_DATABASE_URL = "sqlite:///./test.db"

# Create an engine connected to the test database
# `check_same_thread=False` allows using this engine across multiple threads (FastAPI needs it)
engine = create_engine(TEST_DATABASE_URL, connect_args={"check_same_thread": False})

# Create a new SQLAlchemy session factory bound to the test engine
# autocommit=False -> you must commit manually
# autoflush=False  -> avoids auto-sending pending changes to DB
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create all tables in the test DB (based on your models)
def create_test_db():
    models.Base.metadata.create_all(bind=engine)  # This uses SQLAlchemy metadata to generate tables

# Drop all tables from the test DB (used during teardown)
def drop_test_db():
    models.Base.metadata.drop_all(bind=engine)  # Deletes all tables defined in Base

# -------------------------------
# FIXTURE 1: Set up test DB for entire test session
# -------------------------------
@pytest.fixture(scope="session", autouse=True)  # Automatically runs once per test session
def setup_test_db():
    create_test_db()  # Create tables before any tests run
    yield             # Run all tests
    drop_test_db()    # Drop tables after all tests are done

# -------------------------------
# FIXTURE 2: Provide a clean DB session per module
# -------------------------------
@pytest.fixture(scope="module")  # Scope: one DB session per test module (file)
def db_session():
    session = TestingSessionLocal()  # Create a fresh DB session
    yield session                    # Yield it to test functions
    session.close()                  # Close it after tests in module finish

# -------------------------------
# FUNCTION: Override FastAPI's get_db dependency
# -------------------------------
def override_get_db():
    db = TestingSessionLocal()  # Get a new test session
    try:
        yield db                # Used in dependency injection for routes
    finally:
        db.close()             # Ensure it's closed after use

# Apply the override globally so all routes use the test DB
app.dependency_overrides[get_db] = override_get_db

# -------------------------------
# FIXTURE 3: FastAPI test client
# -------------------------------
@pytest.fixture(scope="module")  # Shared test client across a module
def client():
    with TestClient(app) as c:  # Create a simulated client to send requests
        yield c                 # Use the client in test functions

# -------------------------------
# FIXTURE 4: Insert a test Claim record into DB
# -------------------------------
@pytest.fixture
def test_claim(db_session: Session):  # Use the db_session fixture to get access to DB
    # Create a dummy claim (fields must match your Claim model/schema)
    new_claim = models.Claim(
        claimant_name="Fixture User",  # Valid name
        amount=99.99,                  # Valid amount (float)
        status="pending"              # Must match allowed values in your Enum
    )
    db_session.add(new_claim)        # Add to DB
    db_session.commit()              # Save it
    db_session.refresh(new_claim)    # Refresh to get the autogenerated ID
    return new_claim                 # Make it available to tests
